"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1496],{6275(e,r,n){n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"Computer/Algorithm/\u4e8c\u53c9\u6811","title":"\u4e8c\u53c9\u6811","description":"","source":"@site/vault/docs/Computer/50_Algorithm/\u4e8c\u53c9\u6811.md","sourceDirName":"Computer/50_Algorithm","slug":"/Computer/Algorithm/\u4e8c\u53c9\u6811","permalink":"/docs/Computer/Algorithm/\u4e8c\u53c9\u6811","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":null,"frontMatter":{"modified":"2024-05-21 16:59","date":"2024-04-22 20:39"},"sidebar":"computerSidebar","previous":{"title":"Data Structures","permalink":"/docs/Computer/Algorithm/Data Structures"},"next":{"title":"\u6392\u5e8f\u548c\u67e5\u627e","permalink":"/docs/Computer/Algorithm/\u6392\u5e8f\u548c\u67e5\u627e"}}');var o=n(4848),s=n(8453);const i={modified:"2024-05-21 16:59",date:"2024-04-22 20:39"},l=void 0,d={},a=[];function f(e){const r={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"class TreeNode:\n    def __init__(self, val=0, left=None, right=None) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __repr__(self) -> str:\n        return str(self.val)\n\nclass BinaryTree:\n    def __init__(self, root=None) -> None:\n        self.root = root\n\n    def __iter__(self):\n        if not self.root:\n            return\n        que = [self.root]\n        while que:\n            node = que.pop(0)\n            yield node.val\n            if node.left:\n                que.append(node.left)\n            if node.right:\n                que.append(node.right)\n\n    def __len__(self):\n        return self.size\n\n    def __str__(self) -> str:\n        pass\n\n    @property\n    def size(self):\n        def size_recur(root):\n            if not root:\n                return 0\n            return 1 + size_recur(root.left) + size_recur(root.right)\n        return size_recur(self.root)\n\n    @property\n    def height(self):\n        def height_recur(root):\n            if not root:\n                return 0\n            left_height = height_recur(root.left)\n            right_height = height_recur(root.right)\n            return max(left_height, right_height) + 1\n        return height_recur(self.root)\n\n    @property\n    def is_complete(self):\n        pass\n\n    @property\n    def is_balanced(self):\n        pass\n\n    @property\n    def is_bst(self):\n        pass\n\n    @property\n    def is_symmetric(self):\n        pass\n\n    def equals(self, other):\n        pass\n\n    def print(self):\n        pass\n\n    def dfs(self, order='pre', recur=False):\n        def preorder(root):\n            stack = [root]\n            while stack:\n                node = stack.pop()\n                if node:\n                    yield node.val\n                    stack.append(node.right)\n                    stack.append(node.left)\n        def inorder(root):\n            stack = []\n            while stack or root:\n                while root:\n                    stack.append(root)\n                    root = root.left\n                root = stack.pop()\n                yield root.val\n                root = root.right\n        def postorder(root):\n            # \u521b\u5efa\u4e00\u4e2a\u7a7a\u5217\u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5df2\u7ecf\u8bbf\u95ee\u7684\u8282\u70b9\n            visited_nodes = []\n            stack = [root]\n\n            while stack:\n                current_node = stack.pop()\n                visited_nodes.append(current_node)\n\n                # \u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u5904\u7406\u5de6\u53f3\u5b50\u8282\u70b9\n                if current_node.left:\n                    stack.append(current_node.left)\n\n                if current_node.right:\n                    stack.append(current_node.right)\n\n            # \u5c06 visited_nodes \u5217\u8868\u4e2d\u7684\u8282\u70b9\u6309\u7167\u540e\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u8f93\u51fa\n            while visited_nodes:\n                yield visited_nodes.pop().val\n        def preorder_recur(root):\n            if root:\n                yield root.val\n                yield from preorder_recur(root.left)\n                yield from preorder_recur(root.right)\n        def inorder_recur(root):\n            if root:\n                yield from inorder_recur(root.left)\n                yield root.val\n                yield from inorder_recur(root.right)\n        def postorder_recur(root):\n            if root:\n                yield from postorder_recur(root.left)\n                yield from postorder_recur(root.right)\n                yield root.val\n\n        root = self.root\n        if recur:\n            match order:\n                case 'pre': return preorder_recur(root)\n                case 'in': return inorder_recur(root)\n                case 'post': return postorder_recur(root)\n        else:\n            match order:\n                case 'pre': return preorder(root)\n                case 'in': return inorder(root)\n                case 'post': return postorder(root)\n\n    def bfs(self):\n        if not self.root:\n            return []\n        que = [self.root]\n        res = []\n        while que:\n            level = []\n            for _ in range(len(que)):\n                node = que.pop(0)\n                level.append(node.val)\n                if node.left:\n                    que.append(node.left)\n                if node.right:\n                    que.append(node.right)\n            res.append(level)\n        return res\n\n    def morris_traverse(self):\n        pass\n\n    def serialize(self):\n        def _serialize(root):\n            if root is None:\n                return '#'\n            left = _serialize(root.left)\n            right = _serialize(root.right)\n            return ','.join([str(root.val), left, right])\n        return _serialize(self.root)\n\n    @staticmethod\n    def deserialize(s):\n        lst = s.split(',') if isinstance(s, str) else s\n        return BinaryTree.build_tree(lst)\n\n    @staticmethod\n    def build_tree(lst):\n        val = lst.pop(0)\n        if val in (None, '#'):\n            return None\n        else:\n            node = TreeNode(val)\n            node.left = BinaryTree.build_tree(lst)\n            node.right = BinaryTree.build_tree(lst)\n            return node\n\n    def add(self, val):\n        def add_recur(root, val):\n            if not root:\n                root = TreeNode(val)\n            elif val < root.val:\n                root.left = add_recur(root.left, val)\n            elif val > root.val:\n                root.right = add_recur(root.right, val)\n            return root\n\n        self.root = add_recur(self.root, val)\n\n    def remove(self, val):\n        pass\n\n    def search(self, val):\n        pass\n\n"})})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}},8453(e,r,n){n.d(r,{R:()=>i,x:()=>l});var t=n(6540);const o={},s=t.createContext(o);function i(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);