"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7296],{3813(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>p,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"Computer/Programming/\u89e3\u6790\u6280\u672f","title":"\u89e3\u6790\u6280\u672f","description":"\u5f62\u5f0f\u6587\u6cd5","source":"@site/vault/docs/Computer/60_Programming/\u89e3\u6790\u6280\u672f.md","sourceDirName":"Computer/60_Programming","slug":"/Computer/Programming/\u89e3\u6790\u6280\u672f","permalink":"/docs/Computer/Programming/\u89e3\u6790\u6280\u672f","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1768140815000,"frontMatter":{"modified":"2024-05-21T16:59","url":["http://parsing-techniques.duguying.net/"],"date":"2024-04-22T20:39"},"sidebar":"computerSidebar","previous":{"title":"\u65f6\u533a","permalink":"/docs/Computer/Programming/\u65f6\u533a"},"next":{"title":"IaaS-PaaS-SaaS","permalink":"/docs/Computer/Engineering/IaaS-PaaS-SaaS"}}');var t=r(74848),i=r(28453);const o={modified:"2024-05-21T16:59",url:["http://parsing-techniques.duguying.net/"],date:"2024-04-22T20:39"},p=void 0,l={},a=[{value:"\u5f62\u5f0f\u6587\u6cd5",id:"\u5f62\u5f0f\u6587\u6cd5",level:2},{value:"\u81ea\u52a8\u673a",id:"\u81ea\u52a8\u673a",level:2},{value:"\u89e3\u6790",id:"\u89e3\u6790",level:2},{value:"\u5b9e\u6218",id:"\u5b9e\u6218",level:2}];function c(n){const e={code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"\u5f62\u5f0f\u6587\u6cd5",children:"\u5f62\u5f0f\u6587\u6cd5"}),"\n",(0,t.jsxs)(e.p,{children:["\u5b9a\u4e49:\n",(0,t.jsx)(e.img,{src:r(63502).A+"",width:"1560",height:"958"})]}),"\n",(0,t.jsx)(e.p,{children:"\u5206\u7c7b:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"http://parsing-techniques.duguying.net/ebook/img/2.3.5_1-Fig.2.16.png",alt:""})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"Chomsky_hierarchy",src:r(66241).A+"",width:"1598",height:"922"})}),"\n",(0,t.jsx)(e.p,{children:"\u8868\u793a\u65b9\u6cd5:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"BNF"}),"\n",(0,t.jsx)(e.li,{children:"PEG"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"\u81ea\u52a8\u673a",children:"\u81ea\u52a8\u673a"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:r(64436).A+"",width:"1528",height:"484"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:r(86769).A+"",width:"1534",height:"866"})}),"\n",(0,t.jsx)(e.h2,{id:"\u89e3\u6790",children:"\u89e3\u6790"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u81ea\u9876\u5411\u4e0b"}),"\n",(0,t.jsx)(e.li,{children:"\u81ea\u5e95\u5411\u4e0a"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"http://parsing-techniques.duguying.net/ebook/img/3.5.8_8-Fig.3.11.png",alt:""})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"|800",src:r(42888).A+"",width:"1334",height:"1046"})}),"\n",(0,t.jsx)(e.p,{children:"\u5e38\u89c1 Parser Generator:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Lex & Yacc"}),"\n",(0,t.jsx)(e.li,{children:"Flex & Bison"}),"\n",(0,t.jsx)(e.li,{children:"PLY"}),"\n",(0,t.jsx)(e.li,{children:"Jison"}),"\n",(0,t.jsx)(e.li,{children:"Clojure/instaparse"}),"\n",(0,t.jsx)(e.li,{children:"Rust/Pest"}),"\n",(0,t.jsx)(e.li,{children:"Parsec"}),"\n",(0,t.jsx)(e.li,{children:"ANTLR4"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"\u5b9e\u6218",children:"\u5b9e\u6218"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import re\n\n# \u5b9a\u4e49\u8bcd\u6cd5\u5355\u5143\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u6a21\u5f0f\ntoken_patterns = [\n    ('NUMBER', r'\\d+(\\.\\d+)?'),  # \u5339\u914d\u6570\u5b57\n    ('PLUS', r'\\+'),  # \u5339\u914d\u52a0\u53f7\n    ('MINUS', r'-'),  # \u5339\u914d\u51cf\u53f7\n    ('MULTIPLY', r'\\*'),  # \u5339\u914d\u4e58\u53f7\n    ('DIVIDE', r'/'),  # \u5339\u914d\u9664\u53f7\n    ('LPAREN', r'\\('),  # \u5339\u914d\u5de6\u62ec\u53f7\n    ('RPAREN', r'\\)'),  # \u5339\u914d\u53f3\u62ec\u53f7\n    ('WHITESPACE', r'\\s+')  # \u5339\u914d\u7a7a\u767d\u5b57\u7b26\n]\n\n# \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6765\u8fdb\u884c\u8bcd\u6cd5\u5206\u6790\ndef lexer(expression):\n    tokens = []\n    pos = 0\n\n    while pos < len(expression):\n        match = None\n\n        # \u5c1d\u8bd5\u5339\u914d\u6bcf\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f\u6a21\u5f0f\n        for token_type, pattern in token_patterns:\n            regex = re.compile(pattern)\n            match = regex.match(expression, pos)\n            if match:\n                # \u5982\u679c\u5339\u914d\u6210\u529f\uff0c\u5c06\u5339\u914d\u5230\u7684\u8bcd\u6cd5\u5355\u5143\u52a0\u5165\u5230tokens\u5217\u8868\u4e2d\n                value = match.group(0)\n                if token_type != 'WHITESPACE':\n                    tokens.append((token_type, value))\n                pos = match.end(0)\n                break\n\n        # \u5982\u679c\u6ca1\u6709\u5339\u914d\u5230\u4efb\u4f55\u6a21\u5f0f\uff0c\u8bf4\u660e\u8f93\u5165\u8868\u8fbe\u5f0f\u5b58\u5728\u975e\u6cd5\u5b57\u7b26\n        if not match:\n            raise ValueError(f\"Invalid character: {expression[pos]}\")\n\n    return tokens\n\n# \u6d4b\u8bd5\u8bcd\u6cd5\u5206\u6790\u5668\nexpression = \"3.14 + 2 * (4 - 1)\"\ntokens = lexer(expression)\nfor token_type, value in tokens:\n    print(f\"Token: {token_type}, Value: {value}\")\n\n\n# \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6765\u8fdb\u884c\u8bed\u6cd5\u5206\u6790\ndef parser(tokens):\n    pos = 0\n\n    # \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8e\u89e3\u6790\u6570\u5b57\n    def parse_number():\n        nonlocal pos\n        token_type, value = tokens[pos]\n        if token_type == 'NUMBER':\n            pos += 1\n            return float(value)\n        else:\n            raise ValueError(f\"Expected NUMBER, but got {token_type}\")\n\n    # \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8e\u89e3\u6790\u4e58\u6cd5\u548c\u9664\u6cd5\u8fd0\u7b97\n    def parse_term():\n        nonlocal pos\n        left = parse_factor()\n\n        while pos < len(tokens):\n            token_type, value = tokens[pos]\n            if token_type == 'MULTIPLY':\n                pos += 1\n                right = parse_factor()\n                left *= right\n            elif token_type == 'DIVIDE':\n                pos += 1\n                right = parse_factor()\n                left /= right\n            else:\n                break\n\n        return left\n\n    # \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8e\u89e3\u6790\u52a0\u6cd5\u548c\u51cf\u6cd5\u8fd0\u7b97\n    def parse_expression():\n        nonlocal pos\n        left = parse_term()\n\n        while pos < len(tokens):\n            token_type, value = tokens[pos]\n            if token_type == 'PLUS':\n                pos += 1\n                right = parse_term()\n                left += right\n            elif token_type == 'MINUS':\n                pos += 1\n                right = parse_term()\n                left -= right\n            else:\n                break\n\n        return left\n\n    # \u8f85\u52a9\u51fd\u6570\uff0c\u7528\u4e8e\u89e3\u6790\u62ec\u53f7\u8868\u8fbe\u5f0f\n    def parse_factor():\n        nonlocal pos\n        token_type, value = tokens[pos]\n        if token_type == 'LPAREN':\n            pos += 1\n            result = parse_expression()\n            if pos >= len(tokens) or tokens[pos][0] != 'RPAREN':\n                raise ValueError(\"Missing closing parenthesis\")\n            pos += 1\n            return result\n        else:\n            return parse_number()\n\n    # \u5f00\u59cb\u8fdb\u884c\u8bed\u6cd5\u5206\u6790\n    result = parse_expression()\n\n    # \u68c0\u67e5\u662f\u5426\u5904\u7406\u5b8c\u6240\u6709\u7684\u8bcd\u6cd5\u5355\u5143\n    if pos < len(tokens):\n        raise ValueError(\"Unexpected token\")\n\n    return result\n\n# \u6d4b\u8bd5\u8868\u8fbe\u5f0f\u89e3\u6790\u5668\nexpression = \"3.14 + 2 * (4 - 1)\"\ntokens = lexer(expression)\nresult = parser(tokens)\nprint(f\"Result: {result}\")\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import ply.lex as lex\nimport ply.yacc as yacc\n\n# \u8bcd\u6cd5\u5206\u6790\u5668\ntokens = (\n    'NUMBER',\n    'PLUS',\n    'MINUS',\n    'MULTIPLY',\n    'DIVIDE',\n    'LPAREN',\n    'RPAREN',\n)\n\nt_PLUS = r'\\+'\nt_MINUS = r'-'\nt_MULTIPLY = r'\\*'\nt_DIVIDE = r'/'\nt_LPAREN = r'\\('\nt_RPAREN = r'\\)'\n\ndef t_NUMBER(t):\n    r'\\d+(\\.\\d+)?'\n    t.value = float(t.value)\n    return t\n\nt_ignore = ' \\t'\n\ndef t_error(t):\n    print(f\"Invalid character: {t.value[0]}\")\n    t.lexer.skip(1)\n\nlexer = lex.lex()\n\n# \u8bed\u6cd5\u5206\u6790\u5668\nprecedence = (\n    ('left', 'PLUS', 'MINUS'),\n    ('left', 'MULTIPLY', 'DIVIDE'),\n)\n\ndef p_expression(p):\n    '''\n    expression : expression PLUS expression\n               | expression MINUS expression\n               | expression MULTIPLY expression\n               | expression DIVIDE expression\n               | LPAREN expression RPAREN\n               | NUMBER\n    '''\n    if len(p) == 2:\n        p[0] = p[1]\n    elif p[1] == '(':\n        p[0] = p[2]\n    else:\n        if p[2] == '+':\n            p[0] = p[1] + p[3]\n        elif p[2] == '-':\n            p[0] = p[1] - p[3]\n        elif p[2] == '*':\n            p[0] = p[1] * p[3]\n        elif p[2] == '/':\n            p[0] = p[1] / p[3]\n\ndef p_error(p):\n    print(\"Syntax error\")\n\nparser = yacc.yacc()\n\n# \u6d4b\u8bd5\u8ba1\u7b97\u5668\nwhile True:\n    try:\n        expression = input(\"\u8bf7\u8f93\u5165\u8868\u8fbe\u5f0f\uff1a\")\n        result = parser.parse(expression)\n        print(f\"\u8ba1\u7b97\u7ed3\u679c\uff1a{result}\")\n    except EOFError:\n        break\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},28453(n,e,r){r.d(e,{R:()=>o,x:()=>p});var s=r(96540);const t={},i=s.createContext(t);function o(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function p(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(i.Provider,{value:e},n.children)}},42888(n,e,r){r.d(e,{A:()=>s});const s=r.p+"assets/images/\u89e3\u6790\u6280\u672f-20240713181712772-27940519a860c0d5a2cedd9ec7ca1f73.png"},63502(n,e,r){r.d(e,{A:()=>s});const s=r.p+"assets/images/\u89e3\u6790\u6280\u672f-20240713181709824-1c35e3f15557dd00efb6991f49f7a9c5.png"},64436(n,e,r){r.d(e,{A:()=>s});const s=r.p+"assets/images/\u89e3\u6790\u6280\u672f-20240713181712435-cde879bb1e59312614dcc42038fb38e0.png"},66241(n,e,r){r.d(e,{A:()=>s});const s=r.p+"assets/images/\u89e3\u6790\u6280\u672f-20240713181711633-92b967fafb017e79653c46f3173afd00.png"},86769(n,e,r){r.d(e,{A:()=>s});const s=r.p+"assets/images/\u89e3\u6790\u6280\u672f-20240713181712654-89b7d769894b83c9f0e7f1f0394d7dd0.png"}}]);