"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[49306],{28453(e,n,t){t.d(n,{R:()=>o,x:()=>i});var r=t(96540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},88835(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"Computer/Programming/Rust/serde","title":"serde","description":"json","source":"@site/vault/docs/Computer/60_Programming/Rust/serde.md","sourceDirName":"Computer/60_Programming/Rust","slug":"/Computer/Programming/Rust/serde","permalink":"/docs/Computer/Programming/Rust/serde","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1768098026000,"frontMatter":{},"sidebar":"computerSidebar","previous":{"title":"reqwest","permalink":"/docs/Computer/Programming/Rust/reqwest"},"next":{"title":"tauri","permalink":"/docs/Computer/Programming/Rust/tauri"}}');var s=t(74848),a=t(28453);const o={},i=void 0,l={},u=[{value:"json",id:"json",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"json",children:"json"}),"\n",(0,s.jsxs)(n.p,{children:["Any valid JSON data can be manipulated in the following recursive enum representation. This data structure is ",(0,s.jsx)(n.a,{href:"https://docs.rs/serde_json/latest/serde_json/enum.Value.html",title:"enum serde_json::Value",children:(0,s.jsx)(n.code,{children:"serde_json::Value"})}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"enum Value {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec<Value>),\n    Object(Map<String, Value>),\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "json"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\nserde_json = { version = "1.0", default-features = true, features = ["alloc"] }\nserde = { version = "1.0", features = ["derive"] }\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use serde::{Deserialize, Serialize};\nuse serde_json::{json, Result, Value};\n\n#[derive(Serialize, Deserialize)]\nstruct Person {\n    name: String,\n    age: u8,\n    phones: Vec<String>,\n}\n\nfn typed_example() -> Result<()> {\n    // Some JSON input data as a &str. Maybe this comes from the user.\n    let data = r#"\n        {\n            "name": "John Doe",\n            "age": 43,\n            "phones": [\n                "+44 1234567",\n                "+44 2345678"\n            ]\n        }"#;\n\n    // Parse the string of data into a Person object. This is exactly the\n    // same function as the one that produced serde_json::Value above, but\n    // now we are asking it for a Person as output.\n    let p: Person = serde_json::from_str(data)?;\n\n    // Do things just like with any other Rust data structure.\n    println!("Please call {} at the number {}", p.name, p.phones[0]);\n\n    Ok(())\n}\n\nfn untyped_example() -> Result<()> {\n    // Some JSON input data as a &str. Maybe this comes from the user.\n    let data = r#"\n        {\n            "name": "John Doe",\n            "age": 43,\n            "phones": [\n                "+44 1234567",\n                "+44 2345678"\n            ]\n        }"#;\n\n    // Parse the string of data into serde_json::Value.\n    let v: Value = serde_json::from_str(data)?;\n\n    // Access parts of the data by indexing with square brackets.\n    println!("Please call {} at the number {}", v["name"], v["phones"][0]);\n\n    Ok(())\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Address {\n    street: String,\n    city: String,\n}\n\nfn print_an_address() -> Result<()> {\n    // Some data structure.\n    let address = Address {\n        street: "10 Downing Street".to_owned(),\n        city: "London".to_owned(),\n    };\n\n    // Serialize it to a JSON string.\n    let j = serde_json::to_string(&address)?;\n\n    // Print, write to a file, or send to an HTTP server.\n    println!("{}", j);\n\n    Ok(())\n}\n\nfn main() {\n    let full_name = "John Doe";\n    let age_last_year = 42;\n\n    // The type of `john` is `serde_json::Value`\n    let john = json!({\n        "name": full_name,\n        "age": age_last_year + 1,\n        "phones": [\n            format!("+44 {}", "1234567")\n        ]\n    });\n\n    println!("first phone number: {}", john["phones"][0]);\n\n    // Convert to a string of JSON and print it out\n    println!("{}", john.to_string());\n\n    untyped_example();\n    typed_example();\n    print_an_address();\n}\n'})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);